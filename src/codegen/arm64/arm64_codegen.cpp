#include "syclang/codegen/arm64/arm64_codegen.h"
#include <sstream>

namespace syclang {

ARM64CodeGenerator::ARM64CodeGenerator() {
    arch_ = Architecture::ARM64;
    currentStackOffset_ = 0;
    initRegisters();
}

void ARM64CodeGenerator::initRegisters() {
    registers_ = {
        {"x0", true, 8}, {"x1", true, 8}, {"x2", true, 8},
        {"x3", true, 8}, {"x4", true, 8}, {"x5", true, 8},
        {"x6", true, 8}, {"x7", true, 8}, {"x8", true, 8},
        {"x9", true, 8}, {"x10", true, 8}, {"x11", true, 8},
        {"x12", true, 8}, {"x13", true, 8}, {"x14", true, 8},
        {"x15", true, 8}, {"x16", true, 8}, {"x17", true, 8},
        {"x18", true, 8}, {"x19", false, 8}, {"x20", false, 8},
        {"x21", false, 8}, {"x22", false, 8}, {"x23", false, 8},
        {"x24", false, 8}, {"x25", false, 8}, {"x26", false, 8},
        {"x27", false, 8}, {"x28", false, 8}, {"x29", false, 8},
        {"x30", true, 8} // lr (link register)
    };
}

void ARM64CodeGenerator::generate(std::shared_ptr<IRModule> module) {
    output_.clear();
    
    output_ += "// ARM64 Assembly Generated by SysLang\n";
    output_ += ".section .text\n\n";
    
    // Generate functions
    for (const auto& func : module->functions) {
        output_ += ".global " + func->name + "\n";
        output_ += func->name + ":\n";
        
        emitPrologue(func->name);
        
        // Generate basic blocks
        for (const auto& block : func->blocks) {
            if (block->name != "entry") {
                output_ += block->name + ":\n";
            }
            
            for (const auto& inst : block->instructions) {
                emitInstruction(inst);
            }
        }
        
        emitEpilogue(func->name);
        output_ += "\n";
    }
    
    output_ += ".section .data\n\n";
    
    // Generate global variables
    for (const auto& var : module->globalVariables) {
        output_ += ".global " + var->name + "\n";
        output_ += var->name + ":\n";
        output_ += "    .quad 0\n\n";
    }
}

void ARM64CodeGenerator::emitPrologue(const std::string& funcName) {
    output_ += "    stp x29, x30, [sp, #-16]!\n";
    output_ += "    mov x29, sp\n";
    if (currentStackOffset_ > 0) {
        output_ += "    sub sp, sp, #" + std::to_string(currentStackOffset_) + "\n";
    }
}

void ARM64CodeGenerator::emitEpilogue(const std::string& funcName) {
    if (currentStackOffset_ > 0) {
        output_ += "    add sp, sp, #" + std::to_string(currentStackOffset_) + "\n";
    }
    output_ += "    ldp x29, x30, [sp], #16\n";
    output_ += "    ret\n";
}

void ARM64CodeGenerator::emitInstruction(std::shared_ptr<IRInstruction> inst) {
    switch (inst->opcode) {
        case Opcode::RET: {
            if (inst->operands.size() > 0) {
                output_ += "    mov x0, " + valueToOperand(inst->operands[0]) + "\n";
            }
            break;
        }
        case Opcode::ADD: {
            output_ += "    mov x0, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    add x0, x0, " + valueToOperand(inst->operands[1]) + "\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", x0\n";
            }
            break;
        }
        case Opcode::SUB: {
            output_ += "    mov x0, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    sub x0, x0, " + valueToOperand(inst->operands[1]) + "\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", x0\n";
            }
            break;
        }
        case Opcode::MUL: {
            output_ += "    mov x0, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    mul x0, x0, " + valueToOperand(inst->operands[1]) + "\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", x0\n";
            }
            break;
        }
        case Opcode::DIV: {
            output_ += "    mov x0, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    sdiv x0, x0, " + valueToOperand(inst->operands[1]) + "\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", x0\n";
            }
            break;
        }
        case Opcode::AND: {
            output_ += "    mov x0, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    and x0, x0, " + valueToOperand(inst->operands[1]) + "\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", x0\n";
            }
            break;
        }
        case Opcode::OR: {
            output_ += "    mov x0, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    orr x0, x0, " + valueToOperand(inst->operands[1]) + "\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", x0\n";
            }
            break;
        }
        case Opcode::XOR: {
            output_ += "    mov x0, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    eor x0, x0, " + valueToOperand(inst->operands[1]) + "\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", x0\n";
            }
            break;
        }
        case Opcode::SHL: {
            output_ += "    mov x0, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    lsl x0, x0, " + valueToOperand(inst->operands[1]) + "\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", x0\n";
            }
            break;
        }
        case Opcode::SHR: {
            output_ += "    mov x0, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    lsr x0, x0, " + valueToOperand(inst->operands[1]) + "\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", x0\n";
            }
            break;
        }
        case Opcode::NEG: {
            output_ += "    mov x0, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    neg x0, x0\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", x0\n";
            }
            break;
        }
        case Opcode::NOT: {
            output_ += "    mov x0, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    cmp x0, #0\n";
            output_ += "    cset x0, eq\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", x0\n";
            }
            break;
        }
        case Opcode::BIT_NOT: {
            output_ += "    mov x0, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    mvn x0, x0\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", x0\n";
            }
            break;
        }
        case Opcode::EQ: {
            output_ += "    mov x0, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    cmp x0, " + valueToOperand(inst->operands[1]) + "\n";
            output_ += "    cset x0, eq\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", x0\n";
            }
            break;
        }
        case Opcode::NE: {
            output_ += "    mov x0, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    cmp x0, " + valueToOperand(inst->operands[1]) + "\n";
            output_ += "    cset x0, ne\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", x0\n";
            }
            break;
        }
        case Opcode::LT: {
            output_ += "    mov x0, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    cmp x0, " + valueToOperand(inst->operands[1]) + "\n";
            output_ += "    cset x0, lt\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", x0\n";
            }
            break;
        }
        case Opcode::GT: {
            output_ += "    mov x0, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    cmp x0, " + valueToOperand(inst->operands[1]) + "\n";
            output_ += "    cset x0, gt\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", x0\n";
            }
            break;
        }
        case Opcode::LE: {
            output_ += "    mov x0, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    cmp x0, " + valueToOperand(inst->operands[1]) + "\n";
            output_ += "    cset x0, le\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", x0\n";
            }
            break;
        }
        case Opcode::GE: {
            output_ += "    mov x0, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    cmp x0, " + valueToOperand(inst->operands[1]) + "\n";
            output_ += "    cset x0, ge\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", x0\n";
            }
            break;
        }
        case Opcode::LOAD: {
            auto var = std::dynamic_pointer_cast<IRVariable>(inst->operands[0]);
            if (var) {
                output_ += "    ldr x0, [x29, #" + std::to_string(16 + var->offset) + "]\n";
                if (inst->result) {
                    output_ += "    mov " + valueToOperand(inst->result) + ", x0\n";
                }
            }
            break;
        }
        case Opcode::STORE: {
            auto var = std::dynamic_pointer_cast<IRVariable>(inst->operands[1]);
            if (var) {
                output_ += "    mov x0, " + valueToOperand(inst->operands[0]) + "\n";
                output_ += "    str x0, [x29, #" + std::to_string(16 + var->offset) + "]\n";
            }
            break;
        }
        case Opcode::ALLOCA: {
            // Stack allocation is handled in prologue
            break;
        }
        case Opcode::CALL: {
            // Simplified call handling
            output_ += "    bl external_function\n";
            break;
        }
        case Opcode::BR: {
            output_ += "    b " + inst->label + "\n";
            break;
        }
        case Opcode::CONDBR: {
            output_ += "    cbz x0, false_branch\n";
            output_ += "    b true_branch\n";
            break;
        }
        default:
            break;
    }
}

std::string ARM64CodeGenerator::valueToOperand(std::shared_ptr<IRValue> value) {
    auto constant = std::dynamic_pointer_cast<IRConstant>(value);
    if (constant) {
        return "#" + constant->toString();
    }
    
    auto var = std::dynamic_pointer_cast<IRVariable>(value);
    if (var) {
        if (var->isGlobal) {
            return var->name;
        }
        return "[x29, #" + std::to_string(16 + var->offset) + "]";
    }
    
    return "x0"; // Default
}

std::string ARM64CodeGenerator::emitBinaryOp(Opcode op, std::shared_ptr<IRValue> left,
                                            std::shared_ptr<IRValue> right) {
    // Handled in emitInstruction
    return "";
}

std::string ARM64CodeGenerator::emitUnaryOp(Opcode op, std::shared_ptr<IRValue> operand) {
    // Handled in emitInstruction
    return "";
}

std::string ARM64CodeGenerator::emitComparison(Opcode op) {
    // Handled in emitInstruction
    return "";
}

} // namespace syclang
