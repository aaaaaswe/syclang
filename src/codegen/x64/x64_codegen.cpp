#include "syclang/codegen/x64/x64_codegen.h"
#include <sstream>
#include <iomanip>

namespace syclang {

X64CodeGenerator::X64CodeGenerator() {
    arch_ = Architecture::X64;
    currentStackOffset_ = 0;
    initRegisters();
}

void X64CodeGenerator::initRegisters() {
    registers_ = {
        {"rax", true, 8}, {"rbx", false, 8}, {"rcx", true, 8},
        {"rdx", true, 8}, {"rsi", true, 8}, {"rdi", true, 8},
        {"r8", true, 8}, {"r9", true, 8}, {"r10", true, 8},
        {"r11", true, 8}, {"r12", false, 8}, {"r13", false, 8},
        {"r14", false, 8}, {"r15", false, 8}
    };
}

void X64CodeGenerator::generate(std::shared_ptr<IRModule> module) {
    output_.clear();
    
    output_ += "# x64 Assembly Generated by SysLang\n";
    output_ += ".section .text\n\n";
    
    // Generate functions
    for (const auto& func : module->functions) {
        output_ += ".global " + func->name + "\n";
        output_ += func->name + ":\n";
        
        emitPrologue(func->name);
        
        // Generate basic blocks
        for (const auto& block : func->blocks) {
            if (block->name != "entry") {
                output_ += block->name + ":\n";
            }
            
            for (const auto& inst : block->instructions) {
                emitInstruction(inst);
            }
        }
        
        emitEpilogue(func->name);
        output_ += "\n";
    }
    
    output_ += ".section .data\n\n";
    
    // Generate global variables
    for (const auto& var : module->globalVariables) {
        output_ += ".global " + var->name + "\n";
        output_ += var->name + ":\n";
        output_ += "    .zero 8\n\n";
    }
}

void X64CodeGenerator::emitPrologue(const std::string& funcName) {
    output_ += "    push rbp\n";
    output_ += "    mov rbp, rsp\n";
    output_ += "    sub rsp, " + std::to_string(currentStackOffset_ + 32) + "\n";
}

void X64CodeGenerator::emitEpilogue(const std::string& funcName) {
    output_ += "    leave\n";
    output_ += "    ret\n";
}

void X64CodeGenerator::emitInstruction(std::shared_ptr<IRInstruction> inst) {
    switch (inst->opcode) {
        case Opcode::RET: {
            if (inst->operands.size() > 0) {
                output_ += "    mov rax, " + valueToOperand(inst->operands[0]) + "\n";
            }
            break;
        }
        case Opcode::ADD: {
            output_ += "    mov rax, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    add rax, " + valueToOperand(inst->operands[1]) + "\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", rax\n";
            }
            break;
        }
        case Opcode::SUB: {
            output_ += "    mov rax, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    sub rax, " + valueToOperand(inst->operands[1]) + "\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", rax\n";
            }
            break;
        }
        case Opcode::MUL: {
            output_ += "    mov rax, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    imul rax, " + valueToOperand(inst->operands[1]) + "\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", rax\n";
            }
            break;
        }
        case Opcode::DIV: {
            output_ += "    mov rax, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    cqo\n";
            output_ += "    idiv " + valueToOperand(inst->operands[1]) + "\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", rax\n";
            }
            break;
        }
        case Opcode::AND: {
            output_ += "    mov rax, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    and rax, " + valueToOperand(inst->operands[1]) + "\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", rax\n";
            }
            break;
        }
        case Opcode::OR: {
            output_ += "    mov rax, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    or rax, " + valueToOperand(inst->operands[1]) + "\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", rax\n";
            }
            break;
        }
        case Opcode::XOR: {
            output_ += "    mov rax, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    xor rax, " + valueToOperand(inst->operands[1]) + "\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", rax\n";
            }
            break;
        }
        case Opcode::SHL: {
            output_ += "    mov rax, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    mov rcx, " + valueToOperand(inst->operands[1]) + "\n";
            output_ += "    shl rax, cl\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", rax\n";
            }
            break;
        }
        case Opcode::SHR: {
            output_ += "    mov rax, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    mov rcx, " + valueToOperand(inst->operands[1]) + "\n";
            output_ += "    shr rax, cl\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", rax\n";
            }
            break;
        }
        case Opcode::NEG: {
            output_ += "    mov rax, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    neg rax\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", rax\n";
            }
            break;
        }
        case Opcode::NOT: {
            output_ += "    mov rax, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    test rax, rax\n";
            output_ += "    sete al\n";
            output_ += "    movzx rax, al\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", rax\n";
            }
            break;
        }
        case Opcode::BIT_NOT: {
            output_ += "    mov rax, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    not rax\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", rax\n";
            }
            break;
        }
        case Opcode::EQ: {
            output_ += "    mov rax, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    cmp rax, " + valueToOperand(inst->operands[1]) + "\n";
            output_ += "    sete al\n";
            output_ += "    movzx rax, al\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", rax\n";
            }
            break;
        }
        case Opcode::NE: {
            output_ += "    mov rax, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    cmp rax, " + valueToOperand(inst->operands[1]) + "\n";
            output_ += "    setne al\n";
            output_ += "    movzx rax, al\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", rax\n";
            }
            break;
        }
        case Opcode::LT: {
            output_ += "    mov rax, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    cmp rax, " + valueToOperand(inst->operands[1]) + "\n";
            output_ += "    setl al\n";
            output_ += "    movzx rax, al\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", rax\n";
            }
            break;
        }
        case Opcode::GT: {
            output_ += "    mov rax, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    cmp rax, " + valueToOperand(inst->operands[1]) + "\n";
            output_ += "    setg al\n";
            output_ += "    movzx rax, al\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", rax\n";
            }
            break;
        }
        case Opcode::LE: {
            output_ += "    mov rax, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    cmp rax, " + valueToOperand(inst->operands[1]) + "\n";
            output_ += "    setle al\n";
            output_ += "    movzx rax, al\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", rax\n";
            }
            break;
        }
        case Opcode::GE: {
            output_ += "    mov rax, " + valueToOperand(inst->operands[0]) + "\n";
            output_ += "    cmp rax, " + valueToOperand(inst->operands[1]) + "\n";
            output_ += "    setge al\n";
            output_ += "    movzx rax, al\n";
            if (inst->result) {
                output_ += "    mov " + valueToOperand(inst->result) + ", rax\n";
            }
            break;
        }
        case Opcode::LOAD: {
            auto var = std::dynamic_pointer_cast<IRVariable>(inst->operands[0]);
            if (var) {
                output_ += "    mov rax, [rbp - " + std::to_string(16 + var->offset) + "]\n";
                if (inst->result) {
                    output_ += "    mov " + valueToOperand(inst->result) + ", rax\n";
                }
            }
            break;
        }
        case Opcode::STORE: {
            auto var = std::dynamic_pointer_cast<IRVariable>(inst->operands[1]);
            if (var) {
                output_ += "    mov rax, " + valueToOperand(inst->operands[0]) + "\n";
                output_ += "    mov [rbp - " + std::to_string(16 + var->offset) + "], rax\n";
            }
            break;
        }
        case Opcode::ALLOCA: {
            // Stack allocation is handled in prologue
            break;
        }
        case Opcode::CALL: {
            // For now, assume function name is in operands[0]
            // This is simplified
            output_ += "    call external_function\n";
            break;
        }
        case Opcode::BR: {
            output_ += "    jmp " + inst->label + "\n";
            break;
        }
        case Opcode::CONDBR: {
            output_ += "    cmp rax, 1\n";
            output_ += "    jne false_branch\n";
            output_ += "    jmp true_branch\n";
            break;
        }
        default:
            break;
    }
}

std::string X64CodeGenerator::valueToOperand(std::shared_ptr<IRValue> value) {
    auto constant = std::dynamic_pointer_cast<IRConstant>(value);
    if (constant) {
        return "$" + constant->toString();
    }
    
    auto var = std::dynamic_pointer_cast<IRVariable>(value);
    if (var) {
        if (var->isGlobal) {
            return var->name;
        }
        return "[rbp - " + std::to_string(16 + var->offset) + "]";
    }
    
    return "rax"; // Default
}

std::string X64CodeGenerator::emitBinaryOp(Opcode op, std::shared_ptr<IRValue> left, 
                                           std::shared_ptr<IRValue> right) {
    // Handled in emitInstruction
    return "";
}

std::string X64CodeGenerator::emitUnaryOp(Opcode op, std::shared_ptr<IRValue> operand) {
    // Handled in emitInstruction
    return "";
}

std::string X64CodeGenerator::emitComparison(Opcode op) {
    // Handled in emitInstruction
    return "";
}

} // namespace syclang
